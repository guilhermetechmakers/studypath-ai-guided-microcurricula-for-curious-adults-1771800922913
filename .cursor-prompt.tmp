⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions
 for bestpractices and # Notifications & Scheduler

## Overview
Build a full Notifications & Scheduler feature for StudyPath that lets users manage study reminders, weekly availability, session scheduling, and notification preferences (in-app, push, email). This feature must integrate with the Personalization & Scheduling engine to propose sessions (including spaced review suggestions and milestone pacing), allow editing/canceling, show upcoming sessions and history logs, and persist preferences. Deliver frontend screens/components, backend APIs, database schema, integration points, security, validation, and automated acceptance criteria.

## Page Description (Full Detail)
What this page is:
- A single cohesive page in the StudyPath app where users view and control everything related to scheduling study sessions and notifications. Primary goals are to enable users to: set weekly availability, configure session reminder times and notification channels (push/email/in-app), review and manage upcoming scheduled sessions, accept or modify AI-proposed schedules (including spaced repetition review suggestions and milestone pacing), and browse recent notification/session history.

Goals:
- Let users set and update weekly availability via a visual weekly matrix and default session length.
- Let users select preferred reminder times per session and per day (e.g., morning/evening defaults), and toggle push/email/in-app notifications.
- Surface AI-proposed schedules from Personalization & Scheduling, allow one-click accept/adjust, or manual scheduling.
- Show upcoming sessions with edit/cancel options and reschedule flows that respect availability/conflict rules.
- Maintain an audit/history of recent notifications and session logs (sent, opened, completed).
- Settings must be stored server-side and synchronized across devices.

Connected features:
- Personalization & Scheduling: Receives user availability, preferred session duration, prior knowledge indicators, and notification preferences to generate personalized session schedules (including spaced review and milestone pacing). Also receives feedback when users complete/cancel sessions to adjust future spacing.
- Notifications subsystem: Uses the stored preferences to send push, in-app, and email reminders.
- Calendar export (optional integration point): iCal/Google Calendar export endpoints.
- Analytics: Emits events for scheduling, notifications sent, opened, and session completion.

UI elements & visual guidance:
- Header with page title “Notifications & Scheduler” and a short subtitle explaining purpose.
- Scheduler section (left/top): Weekly availability matrix — a compact 7xN grid representing days and time blocks (e.g., 30/60/90-minute slots or hourly blocks). Each block can be toggled: available/unavailable. Also include controls for default session length and “preferred times” presets (Morning/Afternoon/Evening).
- Reminder Times: Dropdown/select to choose default reminder lead time (e.g., 5/15/30/60 minutes, 1 day). Option to set per-session reminder overrides.
- Notification Toggles: Row of toggles for Push, Email, In-app + per-notification type granular toggles (session reminders, milestone alerts, new curriculum suggestions).
- Upcoming Sessions List: List of next N scheduled sessions with card rows including date/time, duration, curriculum/lesson title, status, and action buttons (Edit, Reschedule, Cancel). Inline edit modal to change time/duration or mark as completed.
- AI Suggestions area: Shows AI-proposed schedule (next 7 sessions) with accept/adjust buttons and preview of spaced-review rationale (e.g., "Review after 3 days to reinforce retention").
- History: Timeline of recent notifications and session logs with status badges (sent, delivered, opened, completed, canceled).
- Visual behavior: Use the existing StudyPath design system: typography, spacing, color palette, rounded cards and subtle borders as per wireframe. Keep the page minimal, professional, and accessible. Provide clear affordances for toggles, buttons, and modals.

API integrations:
- Integrate with backend scheduling APIs (CRUD for availability, sessions, notification preferences).
- Integrate with Personalization & Scheduling engine (POST availability + user model -> GET schedule suggestions).
- Integrate with Notification service (send push/email/in-app; handle delivery & open webhooks).
- Analytics event API for scheduling and notification telemetry.
- No external APIs required for initial build; calendar export optional.

## Components to Build
1. WeeklyAvailabilityMatrix component
   - Interactive 7-day grid (labels Mon-Sun) with time rows (configurable granularity; default 1-hour).
   - Support click/drag to select multiple blocks.
   - Persist changes to backend via debounce (500ms) or Save button.
   - Visual: available blocks colored primary; unavailable muted.

2. SessionDefaults panel
   - Default session duration dropdown (15, 30, 45, 60 min).
   - Preferred times preset toggles (Morning/Afternoon/Evening) mapping to time ranges.
   - Default reminder lead-time selector.

3. NotificationPreferences component
   - Toggle switches for Push, Email, In-app.
   - Sub-toggles for categories: Session Reminders, Milestones, Suggestions.
   - Show current device push token status.

4. UpcomingSessionsList component
   - Fetch & render upcoming sessions (paginated or capped).
   - Actions: Edit (open modal with changes validated against availability), Reschedule (quick-picker showing only available slots), Cancel.
   - Inline status badges and completion button.

5. AIScheduleSuggestions card
   - Fetch suggestions from Personalization & Scheduling (next 7 sessions).
   - Show reasoning: spaced review intervals, milestone pacing.
   - Action: Accept All / Accept & Edit / Ignore.

6. HistoryTimeline component
   - Show recent notifications and session logs with filters (last 7/30/90 days).
   - Each entry: type, timestamp, status, associated session id, open/view metrics.

7. Modals & Forms
   - Edit Session modal with date-time picker, duration, reminder override, and conflict validation.
   - Confirm Cancel modal (optional reschedule suggestion).

8. Backend scheduler & notification services
   - APIs for preferences, availability, session CRUD, suggestion endpoint, notification triggers, and history logs.
   - Worker/cron jobs to schedule notifications, retry logic, and handle timezone conversions.

## Implementation Requirements

### Frontend
- Platform: Expo React Native (consistent with StudyPath mobile app) — implement responsive mobile screens/components. Use app design system tokens for colors, spacings, typography.
- Screens:
  - Notifications & Scheduler main screen composed of the components listed above.
  - Modals: Edit/Reschedule/Confirm Cancel.
- Interactions:
  - WeeklyAvailabilityMatrix supports tap and drag selecting. Provide keyboard-accessible alternatives for accessibility.
  - Toggling notification preferences updates local state and persists to server; show inline success/error toast.
  - Accepting AI suggestions submits to backend to create sessions; show progress state and optimistic UI updates.
  - When editing/rescheduling, validate against availability; if conflict, show suggestion list of next available slots.
  - All times should be displayed in the user’s timezone with ISO storage in UTC on server.
- Offline behavior:
  - Queue changes and sync when online; show offline indicator and last sync time.
- Device push handling:
  - Expose current push token and permission status; if push permission not granted show CTA to enable (flow limited by platform).
- Analytics:
  - Emit events for preference changes, suggestion acceptance, session edits/cancels, notifications opened.

### Backend
- Language/Framework: Node.js (Express or similar) or existing backend stack. Provide RESTful endpoints (and optional GraphQL).
- Database: Postgres preferred (or existing DB). Use timezone-aware timestamp fields.
- Tables/Collections to implement:
  - users (existing)
  - notification_preferences
    - user_id (FK), push_enabled(bool), email_enabled(bool), in_app_enabled(bool), categories JSON (session_reminder/milestone/suggestions bools), updated_at
  - availability_slots
    - id, user_id, day_of_week (0-6), start_time (time), end_time (time), granularity (minutes), created_at, updated_at
    - alternative: store as weekly_availability JSON blob with ranges array
  - sessions
    - id, user_id, curriculum_id, lesson_id, scheduled_at (utc timestamptz), duration_minutes, reminder_lead_minutes, status (scheduled, completed, canceled), source (user, ai), created_at, updated_at
  - notification_logs
    - id, user_id, session_id (nullable), type (email,push,in_app), category, status (queued,sent,delivered,opened,failed), provider_id, payload JSON, timestamp
  - schedule_suggestions
    - id, user_id, suggestion_payload JSON, generated_at, accepted(boolean), accepted_at
  - audit_events (existing analytics pipeline) for events.
- Functions/Jobs:
  - suggestion generator endpoint: accepts user_id, availability, preferences, prior progress -> calls Personalization & Scheduling service -> returns suggested session schedule + rationale for spaced reviews and milestones.
  - session_cron / worker: runs every minute to dispatch scheduled reminders respecting reminder_lead_minutes and user preferences. Enqueue push/email/in-app via Notification Service.
  - retry and dead-letter handling for notification deliveries.
  - webhook endpoints to receive push/email provider delivery/open events and update notification_logs and analytics.
  - timezone normalization functions to convert user local selection <-> server UTC.

### Integration
- Flow:
  - Frontend submits availability and preferences -> backend persists.
  - Frontend requests schedule suggestions -> backend calls Personalization & Scheduling module, combining user model and availability -> returns suggested sessions.
  - On Accept: frontend posts create-sessions request -> backend creates session rows and schedules notifications with worker queue.
  - Worker sends notifications via Notification Service, logs result in notification_logs, and triggers analytics events.
  - When users complete/cancel sessions on frontend, POST updates propagate to Personalization service so spaced review intervals adapt.
- Contract:
  - Suggestion endpoint returns session objects with fields: suggested_at(UTC), duration, reason_text, repeat_rule(optional), dependency (if milestone).
  - Notification payload standard: title, body, deep_link (to lesson), session_id, custom_data JSON.
- Idempotency:
  - Use idempotency keys for create-sessions operations to avoid duplicates.

## User Experience Flow
1. User opens Notifications & Scheduler page. Frontend fetches notification_preferences, availability_slots, upcoming sessions (next 30 days), and recent history.
2. User views weekly availability matrix, toggles blocks to indicate availability. They set default session duration and reminder lead time, then Save (or autosave).
3. The user toggles notification channels (push/email/in-app) and categories. If push is enabled, request platform permission; if denied, show explanation and CTA to system settings.
4. Frontend calls suggestion endpoint to get AI-generated schedule reflecting updated availability and prior progress. Suggestions show spaced review rationale.
5. User taps Accept All to schedule suggested sessions. The frontend sends create-sessions request. Sessions are created server-side and notifications are scheduled.
6. The Upcoming Sessions list updates. For an individual session, user can tap Edit -> modal with date/time picker restricted to available slots; validation prevents conflicts. On save, backend updates session and reschedules notifications.
7. On session time, worker sends reminder per user preference. Notification appears via the selected channel(s). Notification logs update.
8. User completes session in-app; the app marks session completed; backend updates session status and informs Personalization & Scheduling to adjust future spacing.
9. User can view History to see sent reminders and session activity. They can filter and export if needed.

## Technical Specifications
- Data Models:

notification_preferences
- user_id: UUID PK, FK users.id
- push_enabled: boolean
- email_enabled: boolean
- in_app_enabled: boolean
- categories: JSON { session_reminder: bool, milestone: bool, suggestion: bool }
- default_reminder_minutes: integer
- updated_at: timestamptz

availability_slots (or weekly_availability)
Option A (normalized):
- id: UUID
- user_id: UUID FK
- day_of_week: int (0=Sun..6=Sat)
- start_time: time (HH:MM)
- end_time: time
- created_at, updated_at

Option B (blob):
- user_id: UUID PK
- availability: JSON { day_of_week: [ {start: "08:00", end:"10:30"}, ... ] }
- granularity_minutes: int
- updated_at

sessions
- id: UUID
- user_id: UUID
- curriculum_id: UUID
- lesson_id: UUID
- scheduled_at: timestamptz (UTC)
- duration_minutes: int
- reminder_lead_minutes: int
- status: enum('scheduled','completed','canceled','skipped')
- source: enum('user','ai')
- created_at, updated_at

notification_logs
- id: UUID
- user_id: UUID
- session_id: UUID nullable
- type: enum('push','email','in_app')
- category: enum('session_reminder','milestone','suggestion')
- status: enum('queued','sent','delivered','opened','failed')
- provider_id: string nullable
- payload: JSON
- timestamp: timestamptz

schedule_suggestions
- id: UUID
- user_id: UUID
- suggestions: JSON (array of suggested session objects)
- rationale: JSON (spaced review intervals, milestones)
- generated_at: timestamptz
- accepted: boolean
- accepted_at: timestamptz nullable

- API Endpoints:

GET /api/v1/notifications/preferences
- Returns: notification_preferences for current user
- Auth: required

PUT /api/v1/notifications/preferences
- Body: { push_enabled, email_enabled, in_app_enabled, categories, default_reminder_minutes }
- Validates and persists

GET /api/v1/scheduler/availability
- Returns current weekly availability

PUT /api/v1/scheduler/availability
- Body: availability payload (normalized or blob)
- Persist, emit event to suggestion engine

POST /api/v1/scheduler/suggestions
- Body: { user_id (implicit), horizon_days: int (default 14) }
- Returns: suggestions array with rationale

POST /api/v1/scheduler/sessions
- Idempotent create of sessions
- Body: { sessions: [ { idempotency_key, curriculum_id, lesson_id, scheduled_at, duration_minutes, reminder_lead_minutes, source } ] }
- Validates against availability/conflicts

GET /api/v1/scheduler/sessions?from=&to=&limit=
- Returns upcoming sessions

PUT /api/v1/scheduler/sessions/:id
- Update scheduled_at/duration/reminder/status

POST /api/v1/scheduler/sessions/:id/cancel
- Cancels session, optional reason

GET /api/v1/notifications/history?days=
- Returns recent notification_logs

POST /api/v1/notifications/webhook
- Provider webhook to update delivery/open statuses

- Security:
  - Authentication: All endpoints require user authentication (JWT/OAuth token). Tokens validated on each request.
  - Authorization: Users can only read/write their own preferences, availability, sessions, and logs. Use user_id from token, never accept arbitrary user_id in body.
  - Sensitive data: Do not store any PII in notification payloads. Use reference IDs (curriculum_id, lesson_id).
  - Rate limiting: Protect suggestion endpoint and session creation endpoints from abuse (per-user rate limits).
  - Idempotency: Use idempotency-key header/body for creating sessions to prevent duplicates.

- Validation:
  - availability: day_of_week 0-6; times in HH:MM; end_time > start_time; no overlapping ranges per day.
  - notification preferences: booleans and category keys validated against allowed list.
  - scheduled_at: ISO8601 timestamp; must be >= now + minimum lead time (e.g., 10 minutes) or explicit user override allowed.
  - session duration: allowed values 5-240 minutes; default set.
  - reminder_lead_minutes: allowed values matching UI options.
  - suggestion request: horizon_days 1-90.

## Acceptance Criteria
- [ ] User can persist weekly availability and default session settings; changes appear immediately in UI and persist across sessions.
- [ ] User can toggle Push/Email/In-app and category-level notification preferences; backend stores them and worker respects them when sending reminders.
- [ ] AI-generated schedule suggestions are returned for the user, show spaced-review rationale, and user can accept suggestions; accepted sessions are created server-side and visible in Upcoming Sessions.
- [ ] Upcoming Sessions list shows scheduled sessions with Edit/Reschedule/Cancel actions that validate against availability and update both frontend and backend.
- [ ] Notifications are scheduled and logged; when a notification is sent a notification_log entry is created; delivery/open updates from provider webhooks update the log.
- [ ] Timezones are handled correctly: UI shows local times, backend stores UTC, and scheduling/notification worker accounts for DST/timezone boundaries.
- [ ] Security: users cannot access/modify other users' schedules or preferences; all relevant endpoints require authentication.
- [ ] Offline changes queue and sync: if user edits availability offline, changes queue and sync on reconnect, with conflict resolution (last-write-wins with timestamp).

## UI/UX Guidelines
- Follow StudyPath design system for typography, spacing, colors, and components.
- Maintain minimal, professional aesthetic: upper-case section headings (as wireframe), compact card layout, subtle borders, and consistent radius values.
- Accessibility: use proper labels for toggles, proper contrast ratios, and screen-reader friendly time descriptions (e.g., “Available Monday 8:00–9:00 AM”).
- Provide microcopy for edge cases: when push permissions denied, when no availability set, when suggestion conflicts with existing commitments.
- Use smooth transitions and optimistic UI updates where appropriate but ensure consistency with backend state after confirmation.
- Provide clear error states: conflict resolution suggestions, network error toasts, and retry flows.

---

Deliverable expectations:
- Implement frontend components in Expo RN using existing component library tokens.
- Backend REST APIs and DB migrations/scripts for the listed tables/functions.
- A worker/service that enqueues and sends notifications according to user preferences and logs status.
- Unit and integration tests for API endpoints, validation, and worker logic.
- End-to-end test scenario covering accept-suggestion -> session created -> notification sent -> session completed -> personalization feedback loop.

If you want, I can generate:
- Example JSON payloads for each API call,
- SQL migration files for the data models,
- React Native component skeletons (props, events) and sample UI state flows. Which should I produce next? for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Notifications & Scheduler

## Overview
Build a full Notifications & Scheduler feature for StudyPath that lets users manage study reminders, weekly availability, session scheduling, and notification preferences (in-app, push, email). This feature must integrate with the Personalization & Scheduling engine to propose sessions (including spaced review suggestions and milestone pacing), allow editing/canceling, show upcoming sessions and history logs, and persist preferences. Deliver frontend screens/components, backend APIs, database schema, integration points, security, validation, and automated acceptance criteria.

## Page Description (Full Detail)
What this page is:
- A single cohesive page in the StudyPath app where users view and control everything related to scheduling study sessions and notifications. Primary goals are to enable users to: set weekly availability, configure session reminder times and notification channels (push/email/in-app), review and manage upcoming scheduled sessions, accept or modify AI-proposed schedules (including spaced repetition review suggestions and milestone pacing), and browse recent notification/session history.

Goals:
- Let users set and update weekly availability via a visual weekly matrix and default session length.
- Let users select preferred reminder times per session and per day (e.g., morning/evening defaults), and toggle push/email/in-app notifications.
- Surface AI-proposed schedules from Personalization & Scheduling, allow one-click accept/adjust, or manual scheduling.
- Show upcoming sessions with edit/cancel options and reschedule flows that respect availability/conflict rules.
- Maintain an audit/history of recent notifications and session logs (sent, opened, completed).
- Settings must be stored server-side and synchronized across devices.

Connected features:
- Personalization & Scheduling: Receives user availability, preferred session duration, prior knowledge indicators, and notification preferences to generate personalized session schedules (including spaced review and milestone pacing). Also receives feedback when users complete/cancel sessions to adjust future spacing.
- Notifications subsystem: Uses the stored preferences to send push, in-app, and email reminders.
- Calendar export (optional integration point): iCal/Google Calendar export endpoints.
- Analytics: Emits events for scheduling, notifications sent, opened, and session completion.

UI elements & visual guidance:
- Header with page title “Notifications & Scheduler” and a short subtitle explaining purpose.
- Scheduler section (left/top): Weekly availability matrix — a compact 7xN grid representing days and time blocks (e.g., 30/60/90-minute slots or hourly blocks). Each block can be toggled: available/unavailable. Also include controls for default session length and “preferred times” presets (Morning/Afternoon/Evening).
- Reminder Times: Dropdown/select to choose default reminder lead time (e.g., 5/15/30/60 minutes, 1 day). Option to set per-session reminder overrides.
- Notification Toggles: Row of toggles for Push, Email, In-app + per-notification type granular toggles (session reminders, milestone alerts, new curriculum suggestions).
- Upcoming Sessions List: List of next N scheduled sessions with card rows including date/time, duration, curriculum/lesson title, status, and action buttons (Edit, Reschedule, Cancel). Inline edit modal to change time/duration or mark as completed.
- AI Suggestions area: Shows AI-proposed schedule (next 7 sessions) with accept/adjust buttons and preview of spaced-review rationale (e.g., "Review after 3 days to reinforce retention").
- History: Timeline of recent notifications and session logs with status badges (sent, delivered, opened, completed, canceled).
- Visual behavior: Use the existing StudyPath design system: typography, spacing, color palette, rounded cards and subtle borders as per wireframe. Keep the page minimal, professional, and accessible. Provide clear affordances for toggles, buttons, and modals.

API integrations:
- Integrate with backend scheduling APIs (CRUD for availability, sessions, notification preferences).
- Integrate with Personalization & Scheduling engine (POST availability + user model -> GET schedule suggestions).
- Integrate with Notification service (send push/email/in-app; handle delivery & open webhooks).
- Analytics event API for scheduling and notification telemetry.
- No external APIs required for initial build; calendar export optional.

## Components to Build
1. WeeklyAvailabilityMatrix component
   - Interactive 7-day grid (labels Mon-Sun) with time rows (configurable granularity; default 1-hour).
   - Support click/drag to select multiple blocks.
   - Persist changes to backend via debounce (500ms) or Save button.
   - Visual: available blocks colored primary; unavailable muted.

2. SessionDefaults panel
   - Default session duration dropdown (15, 30, 45, 60 min).
   - Preferred times preset toggles (Morning/Afternoon/Evening) mapping to time ranges.
   - Default reminder lead-time selector.

3. NotificationPreferences component
   - Toggle switches for Push, Email, In-app.
   - Sub-toggles for categories: Session Reminders, Milestones, Suggestions.
   - Show current device push token status.

4. UpcomingSessionsList component
   - Fetch & render upcoming sessions (paginated or capped).
   - Actions: Edit (open modal with changes validated against availability), Reschedule (quick-picker showing only available slots), Cancel.
   - Inline status badges and completion button.

5. AIScheduleSuggestions card
   - Fetch suggestions from Personalization & Scheduling (next 7 sessions).
   - Show reasoning: spaced review intervals, milestone pacing.
   - Action: Accept All / Accept & Edit / Ignore.

6. HistoryTimeline component
   - Show recent notifications and session logs with filters (last 7/30/90 days).
   - Each entry: type, timestamp, status, associated session id, open/view metrics.

7. Modals & Forms
   - Edit Session modal with date-time picker, duration, reminder override, and conflict validation.
   - Confirm Cancel modal (optional reschedule suggestion).

8. Backend scheduler & notification services
   - APIs for preferences, availability, session CRUD, suggestion endpoint, notification triggers, and history logs.
   - Worker/cron jobs to schedule notifications, retry logic, and handle timezone conversions.

## Implementation Requirements

### Frontend
- Platform: Expo React Native (consistent with StudyPath mobile app) — implement responsive mobile screens/components. Use app design system tokens for colors, spacings, typography.
- Screens:
  - Notifications & Scheduler main screen composed of the components listed above.
  - Modals: Edit/Reschedule/Confirm Cancel.
- Interactions:
  - WeeklyAvailabilityMatrix supports tap and drag selecting. Provide keyboard-accessible alternatives for accessibility.
  - Toggling notification preferences updates local state and persists to server; show inline success/error toast.
  - Accepting AI suggestions submits to backend to create sessions; show progress state and optimistic UI updates.
  - When editing/rescheduling, validate against availability; if conflict, show suggestion list of next available slots.
  - All times should be displayed in the user’s timezone with ISO storage in UTC on server.
- Offline behavior:
  - Queue changes and sync when online; show offline indicator and last sync time.
- Device push handling:
  - Expose current push token and permission status; if push permission not granted show CTA to enable (flow limited by platform).
- Analytics:
  - Emit events for preference changes, suggestion acceptance, session edits/cancels, notifications opened.

### Backend
- Language/Framework: Node.js (Express or similar) or existing backend stack. Provide RESTful endpoints (and optional GraphQL).
- Database: Postgres preferred (or existing DB). Use timezone-aware timestamp fields.
- Tables/Collections to implement:
  - users (existing)
  - notification_preferences
    - user_id (FK), push_enabled(bool), email_enabled(bool), in_app_enabled(bool), categories JSON (session_reminder/milestone/suggestions bools), updated_at
  - availability_slots
    - id, user_id, day_of_week (0-6), start_time (time), end_time (time), granularity (minutes), created_at, updated_at
    - alternative: store as weekly_availability JSON blob with ranges array
  - sessions
    - id, user_id, curriculum_id, lesson_id, scheduled_at (utc timestamptz), duration_minutes, reminder_lead_minutes, status (scheduled, completed, canceled), source (user, ai), created_at, updated_at
  - notification_logs
    - id, user_id, session_id (nullable), type (email,push,in_app), category, status (queued,sent,delivered,opened,failed), provider_id, payload JSON, timestamp
  - schedule_suggestions
    - id, user_id, suggestion_payload JSON, generated_at, accepted(boolean), accepted_at
  - audit_events (existing analytics pipeline) for events.
- Functions/Jobs:
  - suggestion generator endpoint: accepts user_id, availability, preferences, prior progress -> calls Personalization & Scheduling service -> returns suggested session schedule + rationale for spaced reviews and milestones.
  - session_cron / worker: runs every minute to dispatch scheduled reminders respecting reminder_lead_minutes and user preferences. Enqueue push/email/in-app via Notification Service.
  - retry and dead-letter handling for notification deliveries.
  - webhook endpoints to receive push/email provider delivery/open events and update notification_logs and analytics.
  - timezone normalization functions to convert user local selection <-> server UTC.

### Integration
- Flow:
  - Frontend submits availability and preferences -> backend persists.
  - Frontend requests schedule suggestions -> backend calls Personalization & Scheduling module, combining user model and availability -> returns suggested sessions.
  - On Accept: frontend posts create-sessions request -> backend creates session rows and schedules notifications with worker queue.
  - Worker sends notifications via Notification Service, logs result in notification_logs, and triggers analytics events.
  - When users complete/cancel sessions on frontend, POST updates propagate to Personalization service so spaced review intervals adapt.
- Contract:
  - Suggestion endpoint returns session objects with fields: suggested_at(UTC), duration, reason_text, repeat_rule(optional), dependency (if milestone).
  - Notification payload standard: title, body, deep_link (to lesson), session_id, custom_data JSON.
- Idempotency:
  - Use idempotency keys for create-sessions operations to avoid duplicates.

## User Experience Flow
1. User opens Notifications & Scheduler page. Frontend fetches notification_preferences, availability_slots, upcoming sessions (next 30 days), and recent history.
2. User views weekly availability matrix, toggles blocks to indicate availability. They set default session duration and reminder lead time, then Save (or autosave).
3. The user toggles notification channels (push/email/in-app) and categories. If push is enabled, request platform permission; if denied, show explanation and CTA to system settings.
4. Frontend calls suggestion endpoint to get AI-generated schedule reflecting updated availability and prior progress. Suggestions show spaced review rationale.
5. User taps Accept All to schedule suggested sessions. The frontend sends create-sessions request. Sessions are created server-side and notifications are scheduled.
6. The Upcoming Sessions list updates. For an individual session, user can tap Edit -> modal with date/time picker restricted to available slots; validation prevents conflicts. On save, backend updates session and reschedules notifications.
7. On session time, worker sends reminder per user preference. Notification appears via the selected channel(s). Notification logs update.
8. User completes session in-app; the app marks session completed; backend updates session status and informs Personalization & Scheduling to adjust future spacing.
9. User can view History to see sent reminders and session activity. They can filter and export if needed.

## Technical Specifications
- Data Models:

notification_preferences
- user_id: UUID PK, FK users.id
- push_enabled: boolean
- email_enabled: boolean
- in_app_enabled: boolean
- categories: JSON { session_reminder: bool, milestone: bool, suggestion: bool }
- default_reminder_minutes: integer
- updated_at: timestamptz

availability_slots (or weekly_availability)
Option A (normalized):
- id: UUID
- user_id: UUID FK
- day_of_week: int (0=Sun..6=Sat)
- start_time: time (HH:MM)
- end_time: time
- created_at, updated_at

Option B (blob):
- user_id: UUID PK
- availability: JSON { day_of_week: [ {start: "08:00", end:"10:30"}, ... ] }
- granularity_minutes: int
- updated_at

sessions
- id: UUID
- user_id: UUID
- curriculum_id: UUID
- lesson_id: UUID
- scheduled_at: timestamptz (UTC)
- duration_minutes: int
- reminder_lead_minutes: int
- status: enum('scheduled','completed','canceled','skipped')
- source: enum('user','ai')
- created_at, updated_at

notification_logs
- id: UUID
- user_id: UUID
- session_id: UUID nullable
- type: enum('push','email','in_app')
- category: enum('session_reminder','milestone','suggestion')
- status: enum('queued','sent','delivered','opened','failed')
- provider_id: string nullable
- payload: JSON
- timestamp: timestamptz

schedule_suggestions
- id: UUID
- user_id: UUID
- suggestions: JSON (array of suggested session objects)
- rationale: JSON (spaced review intervals, milestones)
- generated_at: timestamptz
- accepted: boolean
- accepted_at: timestamptz nullable

- API Endpoints:

GET /api/v1/notifications/preferences
- Returns: notification_preferences for current user
- Auth: required

PUT /api/v1/notifications/preferences
- Body: { push_enabled, email_enabled, in_app_enabled, categories, default_reminder_minutes }
- Validates and persists

GET /api/v1/scheduler/availability
- Returns current weekly availability

PUT /api/v1/scheduler/availability
- Body: availability payload (normalized or blob)
- Persist, emit event to suggestion engine

POST /api/v1/scheduler/suggestions
- Body: { user_id (implicit), horizon_days: int (default 14) }
- Returns: suggestions array with rationale

POST /api/v1/scheduler/sessions
- Idempotent create of sessions
- Body: { sessions: [ { idempotency_key, curriculum_id, lesson_id, scheduled_at, duration_minutes, reminder_lead_minutes, source } ] }
- Validates against availability/conflicts

GET /api/v1/scheduler/sessions?from=&to=&limit=
- Returns upcoming sessions

PUT /api/v1/scheduler/sessions/:id
- Update scheduled_at/duration/reminder/status

POST /api/v1/scheduler/sessions/:id/cancel
- Cancels session, optional reason

GET /api/v1/notifications/history?days=
- Returns recent notification_logs

POST /api/v1/notifications/webhook
- Provider webhook to update delivery/open statuses

- Security:
  - Authentication: All endpoints require user authentication (JWT/OAuth token). Tokens validated on each request.
  - Authorization: Users can only read/write their own preferences, availability, sessions, and logs. Use user_id from token, never accept arbitrary user_id in body.
  - Sensitive data: Do not store any PII in notification payloads. Use reference IDs (curriculum_id, lesson_id).
  - Rate limiting: Protect suggestion endpoint and session creation endpoints from abuse (per-user rate limits).
  - Idempotency: Use idempotency-key header/body for creating sessions to prevent duplicates.

- Validation:
  - availability: day_of_week 0-6; times in HH:MM; end_time > start_time; no overlapping ranges per day.
  - notification preferences: booleans and category keys validated against allowed list.
  - scheduled_at: ISO8601 timestamp; must be >= now + minimum lead time (e.g., 10 minutes) or explicit user override allowed.
  - session duration: allowed values 5-240 minutes; default set.
  - reminder_lead_minutes: allowed values matching UI options.
  - suggestion request: horizon_days 1-90.

## Acceptance Criteria
- [ ] User can persist weekly availability and default session settings; changes appear immediately in UI and persist across sessions.
- [ ] User can toggle Push/Email/In-app and category-level notification preferences; backend stores them and worker respects them when sending reminders.
- [ ] AI-generated schedule suggestions are returned for the user, show spaced-review rationale, and user can accept suggestions; accepted sessions are created server-side and visible in Upcoming Sessions.
- [ ] Upcoming Sessions list shows scheduled sessions with Edit/Reschedule/Cancel actions that validate against availability and update both frontend and backend.
- [ ] Notifications are scheduled and logged; when a notification is sent a notification_log entry is created; delivery/open updates from provider webhooks update the log.
- [ ] Timezones are handled correctly: UI shows local times, backend stores UTC, and scheduling/notification worker accounts for DST/timezone boundaries.
- [ ] Security: users cannot access/modify other users' schedules or preferences; all relevant endpoints require authentication.
- [ ] Offline changes queue and sync: if user edits availability offline, changes queue and sync on reconnect, with conflict resolution (last-write-wins with timestamp).

## UI/UX Guidelines
- Follow StudyPath design system for typography, spacing, colors, and components.
- Maintain minimal, professional aesthetic: upper-case section headings (as wireframe), compact card layout, subtle borders, and consistent radius values.
- Accessibility: use proper labels for toggles, proper contrast ratios, and screen-reader friendly time descriptions (e.g., “Available Monday 8:00–9:00 AM”).
- Provide microcopy for edge cases: when push permissions denied, when no availability set, when suggestion conflicts with existing commitments.
- Use smooth transitions and optimistic UI updates where appropriate but ensure consistency with backend state after confirmation.
- Provide clear error states: conflict resolution suggestions, network error toasts, and retry flows.

---

Deliverable expectations:
- Implement frontend components in Expo RN using existing component library tokens.
- Backend REST APIs and DB migrations/scripts for the listed tables/functions.
- A worker/service that enqueues and sends notifications according to user preferences and logs status.
- Unit and integration tests for API endpoints, validation, and worker logic.
- End-to-end test scenario covering accept-suggestion -> session created -> notification sent -> session completed -> personalization feedback loop.

If you want, I can generate:
- Example JSON payloads for each API call,
- SQL migration files for the data models,
- React Native component skeletons (props, events) and sample UI state flows. Which should I produce next?

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.