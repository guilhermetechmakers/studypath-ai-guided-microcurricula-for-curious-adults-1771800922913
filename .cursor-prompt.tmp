⚠️ CRITICAL EXECUTION RULES - READ FIRST ⚠️
❌ NEVER run: npm run dev, npm start, yarn dev, pnpm dev, or ANY development server
❌ NEVER run: long-running processes, servers, or commands that don't exit
❌ NEVER test the application by starting it
✅ ALLOWED: npm install, npm run build, npm run test (if needed)
✅ YOUR TASK: Create/modify files only, then STOP and EXIT immediately
⚠️ The MCP server handles all testing and validation separately

You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI).

=== DESIGN REFERENCE (MANDATORY) ===
# Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions


*IMPORTANT*: For every page or component refer to # Modern Design Best Practices

## Philosophy

Create unique, memorable experiences while maintaining consistency through modern design principles. Every project should feel distinct yet professional, innovative yet intuitive.

---

## Landing Pages & Marketing Sites

### Hero Sections
**Go beyond static backgrounds:**
- Animated gradients with subtle movement
- Particle systems or geometric shapes floating
- Interactive canvas backgrounds (Three.js, WebGL)
- Video backgrounds with proper fallbacks
- Parallax scrolling effects
- Gradient mesh animations
- Morphing blob animations


### Layout Patterns
**Use modern grid systems:**
- Bento grids (asymmetric card layouts)
- Masonry layouts for varied content
- Feature sections with diagonal cuts or curves
- Overlapping elements with proper z-index
- Split-screen designs with scroll-triggered reveals

**Avoid:** Traditional 3-column equal grids

### Scroll Animations
**Engage users as they scroll:**
- Fade-in and slide-up animations for sections
- Scroll-triggered parallax effects
- Progress indicators for long pages
- Sticky elements that transform on scroll
- Horizontal scroll sections for portfolios
- Text reveal animations (word by word, letter by letter)
- Number counters animating into view

**Avoid:** Static pages with no scroll interaction

### Call-to-Action Areas
**Make CTAs impossible to miss:**
- Gradient buttons with hover effects
- Floating action buttons with micro-interactions
- Animated borders or glowing effects
- Scale/lift on hover
- Interactive elements that respond to mouse position
- Pulsing indicators for primary actions

---

## Dashboard Applications

### Layout Structure
**Always use collapsible side navigation:**
- Sidebar that can collapse to icons only
- Smooth transition animations between states
- Persistent navigation state (remember user preference)
- Mobile: drawer that slides in/out
- Desktop: sidebar with expand/collapse toggle
- Icons visible even when collapsed

**Structure:**
```
/dashboard (layout wrapper with sidebar)
  /dashboard/overview
  /dashboard/analytics
  /dashboard/settings
  /dashboard/users
  /dashboard/projects
```

All dashboard pages should be nested inside the dashboard layout, not separate routes.

### Data Tables
**Modern table design:**
- Sticky headers on scroll
- Row hover states with subtle elevation
- Sortable columns with clear indicators
- Pagination with items-per-page control
- Search/filter with instant feedback
- Selection checkboxes with bulk actions
- Responsive: cards on mobile, table on desktop
- Loading skeletons, not spinners
- Empty states with illustrations or helpful text

**Use modern table libraries:**
- TanStack Table (React Table v8)
- AG Grid for complex data
- Data Grid from MUI (if using MUI)

### Charts & Visualizations
**Use the latest charting libraries:**
- Recharts (for React, simple charts)
- Chart.js v4 (versatile, well-maintained)
- Apache ECharts (advanced, interactive)
- D3.js (custom, complex visualizations)
- Tremor (for dashboards, built on Recharts)

**Chart best practices:**
- Animated transitions when data changes
- Interactive tooltips with detailed info
- Responsive sizing
- Color scheme matching design system
- Legend placement that doesn't obstruct data
- Loading states while fetching data

### Dashboard Cards
**Metric cards should stand out:**
- Gradient backgrounds or colored accents
- Trend indicators (↑ ↓ with color coding)
- Sparkline charts for historical data
- Hover effects revealing more detail
- Icon representing the metric
- Comparison to previous period

---

## Color & Visual Design

### Color Palettes
**Create depth with gradients:**
- Primary gradient (not just solid primary color)
- Subtle background gradients
- Gradient text for headings
- Gradient borders on cards
- Elevated surfaces for depth

**Color usage:**
- 60-30-10 rule (dominant, secondary, accent)
- Consistent semantic colors (success, warning, error)
- Accessible contrast ratios (WCAG AA minimum)

### Typography
**Create hierarchy through contrast:**
- Large, bold headings (48-72px for heroes)
- Clear size differences between levels
- Variable font weights (300, 400, 600, 700)
- Letter spacing for small caps
- Line height 1.5-1.7 for body text
- Inter, Poppins, or DM Sans for modern feel

### Shadows & Depth
**Layer UI elements:**
- Multi-layer shadows for realistic depth
- Colored shadows matching element color
- Elevated states on hover
- Neumorphism for special elements (sparingly)

---

## Interactions & Micro-animations

### Button Interactions
**Every button should react:**
- Scale slightly on hover (1.02-1.05)
- Lift with shadow on hover
- Ripple effect on click
- Loading state with spinner or progress
- Disabled state clearly visible
- Success state with checkmark animation

### Card Interactions
**Make cards feel alive:**
- Lift on hover with increased shadow
- Subtle border glow on hover
- Tilt effect following mouse (3D transform)
- Smooth transitions (200-300ms)
- Click feedback for interactive cards

### Form Interactions
**Guide users through forms:**
- Input focus states with border color change
- Floating labels that animate up
- Real-time validation with inline messages
- Success checkmarks for valid inputs
- Error states with shake animation
- Password strength indicators
- Character count for text areas

### Page Transitions
**Smooth between views:**
- Fade + slide for page changes
- Skeleton loaders during data fetch
- Optimistic UI updates
- Stagger animations for lists
- Route transition animations

---

## Mobile Responsiveness

### Mobile-First Approach
**Design for mobile, enhance for desktop:**
- Touch targets minimum 44x44px
- Generous padding and spacing
- Sticky bottom navigation on mobile
- Collapsible sections for long content
- Swipeable cards and galleries
- Pull-to-refresh where appropriate

### Responsive Patterns
**Adapt layouts intelligently:**
- Hamburger menu → full nav bar
- Card grid → stack on mobile
- Sidebar → drawer
- Multi-column → single column
- Data tables → card list
- Hide/show elements based on viewport

---

## Loading & Empty States

### Loading States
**Never leave users wondering:**
- Skeleton screens matching content layout
- Progress bars for known durations
- Animated placeholders
- Spinners only for short waits (<3s)
- Stagger loading for multiple elements
- Shimmer effects on skeletons

### Empty States
**Make empty states helpful:**
- Illustrations or icons
- Helpful copy explaining why it's empty
- Clear CTA to add first item
- Examples or suggestions
- No "no data" text alone

---

## Unique Elements to Stand Out

### Distinctive Features
**Add personality:**
- Custom cursor effects on landing pages
- Animated page numbers or section indicators
- Unusual hover effects (magnification, distortion)
- Custom scrollbars
- Glassmorphism for overlays
- Animated SVG icons
- Typewriter effects for hero text
- Confetti or celebration animations for actions

### Interactive Elements
**Engage users:**
- Drag-and-drop interfaces
- Sliders and range controls
- Toggle switches with animations
- Progress steps with animations
- Expandable/collapsible sections
- Tabs with slide indicators
- Image comparison sliders
- Interactive demos or playgrounds

---

## Consistency Rules

### Maintain Consistency
**What should stay consistent:**
- Spacing scale (4px, 8px, 16px, 24px, 32px, 48px, 64px)
- Border radius values
- Animation timing (200ms, 300ms, 500ms)
- Color system (primary, secondary, accent, neutrals)
- Typography scale
- Icon style (outline vs filled)
- Button styles across the app
- Form element styles

### What Can Vary
**Project-specific customization:**
- Color palette (different colors, same system)
- Layout creativity (grids, asymmetry)
- Illustration style
- Animation personality
- Feature-specific interactions
- Hero section design
- Card styling variations
- Background patterns or textures

---

## Technical Excellence

### Performance
- Optimize images (WebP, lazy loading)
- Code splitting for faster loads
- Debounce search inputs
- Virtualize long lists
- Minimize re-renders
- Use proper memoization

### Accessibility
- Keyboard navigation throughout
- ARIA labels where needed
- Focus indicators visible
- Screen reader friendly
- Sufficient color contrast
- Respect reduced motion preferences

---

## Key Principles

1. **Be Bold** - Don't be afraid to try unique layouts and interactions
2. **Be Consistent** - Use the same patterns for similar functions
3. **Be Responsive** - Design works beautifully on all devices
4. **Be Fast** - Animations are smooth, loading is quick
5. **Be Accessible** - Everyone can use what you build
6. **Be Modern** - Use current design trends and technologies
7. **Be Unique** - Each project should have its own personality
8. **Be Intuitive** - Users shouldn't need instructions
 for bestpractices and # Curriculum Detail / Editor

## Overview
Build a complete, production-ready "Curriculum Detail / Editor" feature for StudyPath: an editable, collaborative page that displays a saved curriculum (chapters → lessons), allows deep editing, reordering, AI-driven rewrites and Q&A, integrates search/filter and export/import, and connects to the Interactive Lesson Viewer and AI Curriculum Generation subsystems. This deliverable should include frontend UI, backend APIs, data models, integration points to AI services, search/embedding systems, and export/import pipelines. Provide concrete component-level instructions, API contracts, validation rules, and acceptance criteria so an engineering team or AI development tool can implement the feature end-to-end.

## Page Description (Full Detail)
What this page is:
- The Curriculum Detail / Editor is the canonical editable view for a single curriculum created by the AI or imported by a user. It displays the full tree: chapters and nested lessons (including optional "deep dive" sections), metadata, versioning, and collaboration tools. Users primarily use it to customize and refine AI-generated curricula before adopting or studying them.

Goals:
- Let users inspect a generated curriculum end-to-end.
- Allow structural edits: rename curriculum, add/remove chapters, reorder chapters & lessons via drag-and-drop, add/remove lessons and deep-dive sections.
- Allow content edits: inline editing for lesson titles, summaries, full lesson body, media placeholders, citations, and estimated times.
- Provide AI actions: rewrite a lesson (simplify, make technical, reframe for a different prior knowledge), generate alternate explanations, or answer follow-up questions anchored in the lesson context.
- Support collaboration: comments, read-only share links, share with collaborators (optional).
- Maintain audit trail: version history with diffs and revert.
- Integrate with Search & Filter, Interactive Lesson Viewer, Export & Import, and AI Curriculum Generation.

Connected features:
- Search & Filter: Search within this curriculum (and across the account) using full-text and embedding similarity; autosuggest on the title and text fields; filters for tags, estimated time, completeness, and media presence.
- Interactive Lesson Viewer: Open individual lessons in an interactive viewer modal/page for study mode (media rendering, expand/collapse deep dives, Q&A, micro-checks, notes).
- Export & Import: Export this curriculum (and attached notes/progress) to PDF, Markdown, CSV; accept imports/merges from OPML/Markdown.
- On-Demand AI Q&A & Rewrites: Provide an AI assistant panel scoped to the selected lesson, which receives lesson context (text, images, citations) and returns responses or updated lesson drafts.
- AI Curriculum Generation: Allow re-generation of subtrees or entire curriculum from an updated prompt or parameters, with diff preview.

UI elements and visual guidance (implement using the project design system / UI Component Kit):
- Curriculum Header: title (editable inline), short description/abstract, metadata row (created date, last edited, total estimated time, tags, privacy), primary action buttons (Publish/Adopt, Export, Duplicate, Share), and audit/version dropdown.
- Chapter List Panel (left/main column): collapsible list of chapters in order. Each chapter shows title, estimated time, count of lessons, drag handle, and controls to add/delete/rename.
- Lesson Cards (nested under chapters): compact card with lesson title, short summary, estimated time, thumbnail/media placeholder, badge for deep-dive presence, quick actions (Edit inline, AI-Rewrite, Open in Viewer, Move/Drag), and inline progress toggle (mark complete/in-progress).
- Central Editor / Canvas (right/main area): when a lesson is selected, show full editor: WYSIWYG or rich-text block editor with support for headings, lists, images, citations, code blocks, callouts, and "Deep Dive" collapsible blocks. Top of editor shows lesson metadata (estimated time, difficulty, tags, citations) and AI action bar (Ask AI, Rewrite: simpler/technical/concise, Generate alternative examples).
- Global Controls: top-right actions: Save, Undo/Redo, Publish, Duplicate, Export, Share. Autosave indicator and explicit Save button if needed.
- Audit Trail & Version History: side panel or modal listing versions with timestamp, author, change summary, diff preview, and revert button.
- Collaboration Controls: comment thread per lesson or per block, presence indicators, share link modal.
- Search Bar & Filters: persistent search input with autosuggest; filters (tags, estimated time range, lesson completeness, media present). Search results highlight and allow opening items in the editor.
- Toasts & Modals: confirmations for destructive actions (delete chapter/lesson), AI operation progress modals, import/export settings modal.

API integrations:
- AI services: endpoints to prompt models for curriculum generation, lesson rewrites, question-answering, and text-to-embedding generation.
- Search service: vector store for embeddings (e.g., Pinecone / Milvus / Redis OM), full-text index (e.g., ElasticSearch / Postgres full-text).
- Storage service: object storage for images/media, export artifacts.
- Backend: REST/GraphQL endpoints for curriculum CRUD, versioning, collaboration, import/export jobs, and progress tracking.

## Components to Build
1. CurriculumHeader component
   - Inline editable title/description with autosave + save UI.
   - Metadata display and control buttons: Publish, Export, Duplicate, Share.
   - API calls: PATCH /curricula/:id for title/description/tags.

2. ChapterList & ChapterItem
   - Draggable list using a robust drag-and-drop library (e.g., react-beautiful-dnd or dnd-kit).
   - Expand/collapse chapters to reveal LessonCards.
   - Controls: add chapter, rename, delete (with modal confirmation), reorder.

3. LessonCard
   - Compact preview of lesson: title, summary, estimated time, thumbnail placeholder.
   - Action buttons: Edit (open in Canvas), AI Rewrite (open AI action modal), Open Viewer (open Interactive Lesson Viewer), Move/Drag, Mark Complete.
   - Badge: deep-dive count, media presence.

4. LessonEditor (Canvas)
   - Rich text editor with block structure (Title, Summary, Body, Deep Dive blocks).
   - Block-level operations: add/remove deep dive, collapse/expand, move block up/down.
   - Support media insertion: image upload placeholders and image request suggestions from AI (list of suggested images per lesson).
   - Inline AI Action Bar: Ask AI, Rewrite options (simpler/technical/concise), Alternate examples generator, Regenerate lesson.
   - Autosave & explicit Save; Undo/Redo stack.
   - API: PUT/PATCH /curricula/:id/lessons/:lessonId

5. AI Action Modal / Panel
   - Context-aware prompt builder: include selected lesson text, metadata, and user-chosen rewrite parameters.
   - Options: rewrite tone (simpler/more technical/more concise), preserve/cite sources, generate alternative examples, produce MC micro-check questions.
   - Show AI output side-by-side diff with proposed changes and accept/reject granular changes (apply to lesson).
   - API interactions: POST /ai/rewrite, POST /ai/qa

6. Interactive Lesson Viewer
   - Read-only but interactive mode for the lesson: render media, expand/collapse deep dives, inline Q&A, micro-checks, notes panel, and progress controls.
   - Integrate with On-Demand AI Q&A: message box sends the current lesson context.
   - Track progress updates to backend.

7. Search & Filter Panel / Bar
   - Autosuggest for curriculum titles, lesson titles, and tags.
   - Perform combined full-text + embedding similarity search; show highlighted snippets and ranked list with facets (tags, media presence, estimated time).
   - API: GET /search?q=...&filters=...

8. Export & Import
   - Export modal: choose format(s) (PDF, Markdown, ZIP of Markdown+images, CSV for lesson metadata), options (include notes/progress), and theme options for PDF.
   - Implement export jobs: POST /curricula/:id/export that returns job id and download link.
   - Import modal: upload OPML/Markdown; show parse preview and merge options (replace/append/create new).
   - Import API: POST /import with parsing and validation; map imported outline to internal schema.

9. Versioning & Audit Trail
   - Backend version store for curriculum and lesson snapshots.
   - UI list of versions with diffs and revert action.
   - API: GET /curricula/:id/versions, POST /curricula/:id/versions/:versionId/revert

10. UI Component Kit (Design System)
    - Buttons, modals, forms, loaders, cards, badges, toasts, editors, avatars, dropdowns, drag handles.
    - Accessibility-ready components (keyboard nav for drag/drop, aria labels, focus states).

## Implementation Requirements

### Frontend
- Framework: React (web) using TypeScript. For mobile parity, components should be portable to React Native / Expo later; keep logic separated from platform-specific UI.
- State management: use Redux Toolkit or React Query for server state and optimistic updates; local editor state with undo/redo stack.
- Editor: use ProseMirror/TipTap or Slate for block-level editing and nested collapsible "Deep Dive" blocks. Ensure plugin for custom blocks and annotations.
- Drag-and-drop: use dnd-kit with sortable context for nested drag (chapters and lessons).
- AI Interactions:
  - Create a modular AI client wrapper that calls backend AI endpoints, shows progress, streaming responses where possible.
  - Provide client-side helpers to build AI prompts: include lesson text, user preferences (tone, depth), and curriculum context (prior knowledge, time).
- Autosave: debounce saves (e.g., 1.5s after edit) and show unsaved changes indicator; allow explicit save and version snapshot triggers.
- Accessibility: keyboard operations for reordering, aria attributes for editor blocks, high-contrast modes.
- Tests: unit tests for components, integration tests for drag-and-drop and editor, end-to-end tests for main user flows.

### Backend
- Tech: Node.js with TypeScript (Express or Fastify) or a GraphQL server (Apollo). Use Postgres for relational data and versioning, and a vector store (Pinecone/Redis/Milvus) for embeddings.
- Database Schemas (high-level):
  - curricula table: id, owner_id, title, description, tags (jsonb), estimated_time_mins, status (draft/published), privacy, created_at, updated_at, metadata jsonb.
  - chapters table: id, curriculum_id, title, position, metadata jsonb, created_at, updated_at.
  - lessons table: id, chapter_id, curriculum_id, title, summary, body (rich JSON document), estimated_time_mins, difficulty, media (jsonb), embeddings (vector), position, created_at, updated_at.
  - lesson_versions table: id, lesson_id, curriculum_id, snapshot (JSONB), author_id, change_summary, created_at.
  - curriculum_versions table: id, curriculum_id, snapshot (JSONB), author_id, change_summary, created_at.
  - notes table: id, user_id, lesson_id, content, created_at, updated_at.
  - progress table: id, user_id, lesson_id, status (not_started/in_progress/completed), last_active_at, time_spent_seconds.
  - ai_jobs table: id, user_id, type (rewrite/qa/generate/export), status, input_payload (jsonb), output_payload (jsonb), started_at, finished_at.
- Endpoints (see API Endpoints section).
- AI services:
  - POST /ai/curriculum/generate: accepts prompt and parameters (time, depth, focus, priorKnowledge) and returns structured curriculum draft (chapters -> lessons) with estimated times, image suggestions, and citations.
  - POST /ai/rewrite: accepts lesson context and rewrite params; returns revised lesson body with diff metadata.
  - POST /ai/qa: accepts context and question; returns answer plus citations and suggested lesson edits.
  - POST /ai/embed: returns embeddings for supplied text for indexing.
- Search:
  - Ingest lesson and curriculum text into full-text index and produce embeddings to store in vector DB. Provide combined search endpoint that ranks by hybrid score.
- Export/Import:
  - Implement background job worker (BullMQ/Sidekiq-style) for heavy tasks: PDF generation, markdown conversion, image bundling, import parsing & validation.
- Versioning:
  - Create snapshots on major changes or on user request. Store diffs and full snapshots to allow revert.
- Security:
  - All endpoints require authentication (JWT/OAuth). Authorization rules: users can only edit curricula they own or that are shared with edit permissions. Provide role-based access for collaborators.

### Integration
- Frontend calls backend REST/GraphQL endpoints for CRUD and AI jobs. Backend proxies calls to AI provider (OpenAI/Anthropic/etc.) and to vector store.
- When a lesson is saved: update lessons table, generate new embedding asynchronously (POST /ai/embed), update vector store, and re-index in full-text search.
- AI Rewrite flow:
  - Frontend sends rewrite request to backend with lesson_id, rewrite_params.
  - Backend calls AI service with constructed prompt including lesson snapshot and parameters; stores ai_job record; streams/returns results.
  - On accept, frontend applies patch to lesson via PATCH /curricula/:id/lessons/:lessonId and creates a lesson_version snapshot.
- Export flow:
  - User initiates export; backend enqueues export job; worker generates artifact, stores in S3, and updates ai_jobs with download URL.
- Import flow:
  - Upload file to backend; worker parses file into internal schema, returns preview; user confirms mapping; then worker persists as new curriculum or merged into existing.

## User Experience Flow
1. Entry: User opens Curriculum Detail for a selected curriculum (GET /curricula/:id). Page loads curriculum header, chapter list, and first lesson in Editor or a prompt to select a lesson.
2. Navigation: User collapses/expands chapters, uses search bar to find a lesson, or uses filters to narrow content.
3. Reorder: User drags lessons between chapters or reorders chapters. On drop, frontend optimistically reorders and sends PATCH /curricula/:id/reorder with new positions; backend validates and persists.
4. Edit: User clicks a LessonCard -> LessonEditor opens. User edits text/blocks. Autosave persists changes after debounce. Each save creates a version snapshot if changes are significant.
5. Deep Dive: User adds a Deep Dive block: an empty collapsible block in the lesson. User can move it, edit it, or delete it.
6. AI Rewrite: User selects a rewrite option (simpler/more technical). AI panel opens showing proposed rewrite side-by-side; user accepts fully or partially. On accept, changes are applied and a version snapshot created.
7. On-Demand Q&A: In the editor or Interactive Viewer, user asks a question. The system sends lesson context to AI and returns anchored answers; user can insert answer back into lesson as a note or content block.
8. Preview & Viewer: User opens Interactive Lesson Viewer to preview how learners will see the lesson. Viewer supports micro-checks and notes.
9. Export/Import: User exports curriculum to PDF/Markdown via Export modal. For import, user uploads OPML/Markdown, previews mapping, and confirms merge/create.
10. Version & Revert: User opens version history, compares diffs, and reverts to a prior version if desired.
11. Publish/Adopt: When satisfied, user clicks Publish or Adopt to mark curriculum as ready for study; this triggers publishing workflow and optionally notifies collaborators.

## Technical Specifications

- Data Models (detailed)
  - Curriculum
    - id: uuid
    - owner_id: uuid
    - title: string (max 256)
    - description: string (nullable)
    - tags: jsonb [string]
    - estimated_time_mins: integer
    - status: enum [draft, published, archived]
    - privacy: enum [private, shared, public]
    - metadata: jsonb (e.g., priorKnowledge, focusAreas)
    - created_at, updated_at
  - Chapter
    - id: uuid
    - curriculum_id: uuid (fk)
    - title: string
    - position: integer
    - metadata: jsonb
    - created_at, updated_at
  - Lesson
    - id: uuid
    - chapter_id: uuid (fk)
    - curriculum_id: uuid (fk)
    - title: string
    - summary: text
    - body: jsonb (block structure with types: paragraph, heading, image, deep_dive, quiz)
    - estimated_time_mins: integer
    - difficulty: enum [intro, intermediate, advanced]
    - media: jsonb [{type, url, caption}]
    - citations: jsonb [{text, url}]
    - embeddings_id: string (ref to vector store id)
    - position: integer
    - created_at, updated_at
  - LessonVersion
    - id, lesson_id, curriculum_id, snapshot: jsonb, author_id, change_summary, created_at
  - AIJob
    - id, user_id, type, status, input_payload, output_payload, started_at, finished_at

- API Endpoints (examples)
  - GET /api/curricula/:id
  - PATCH /api/curricula/:id
  - POST /api/curricula/:id/duplicate
  - POST /api/curricula/:id/export  -> returns job id
  - POST /api/curricula/import (multipart)
  - POST /api/curricula/:id/chapters (create)
  - PATCH /api/chapters/:id (rename/move)
  - DELETE /api/chapters/:id
  - PATCH /api/curricula/:id/reorder  (payload: {chapters:[{id,position}], lessons:[{id,position,chapterId}]})
  - GET /api/curricula/:id/versions
  - POST /api/curricula/:id/versions/:versionId/revert
  - GET /api/lessons/:lessonId
  - PATCH /api/lessons/:lessonId
  - POST /api/lessons/:lessonId/ai/rewrite  (body: {params})
  - POST /api/lessons/:lessonId/ai/qa (body: {question, contextOptions})
  - POST /api/ai/curriculum/generate (body: {prompt, timeEstimateMins, depth, focusAreas, priorKnowledge})
  - POST /api/ai/embed (body: {texts:[]})
  - GET /api/search?q=&filters=
  - POST /api/export/jobs/:jobId/status

- Security
  - Auth: JWT Bearer tokens; endpoints validate token and check ownership or shared access based on ACL.
  - Authorization: CRUD restricted to owner or collaborators with edit permission; read access for shared/public.
  - Rate limiting for AI endpoints per user to avoid abuse.
  - Data privacy: exports only available to authorized users; signed temporary URLs for export downloads.
  - Input sanitization: sanitize HTML and rich text on save to prevent XSS. Use CSP and store only safe JSON block structures.

- Validation
  - Title: required, 1-256 chars.
  - Estimated time: integer >= 1 and < 10000.
  - Lesson body: validated JSON schema with allowed block types.
  - Import: validate file size, format; produce parsing errors with line/offset where possible.
  - Reorder payload: validate that provided IDs belong to the curriculum.

## Acceptance Criteria
- [ ] Curriculum page loads with full chapter/lesson tree for a saved curriculum; lesson selection loads editor content.
- [ ] User can reorder chapters and lessons via drag-and-drop; reordering persists and positions are stable across reloads.
- [ ] Inline editing: user can edit lesson title, summary, and the body; autosave and explicit save both persist changes and create version snapshots.
- [ ] Deep-dive sections can be added, expanded/collapsed, moved, and deleted; their presence is reflected in lesson metadata.
- [ ] AI rewrite: user can request a rewrite (simpler/more technical/concise); AI returns suggested copy; user can accept to update lesson and create version snapshot.
- [ ] On-demand Q&A returns context-anchored answers and allows inserting answers into notes or lesson body.
- [ ] Search & Filter returns results across curricula, lessons, and notes; supports autosuggest and facet filters.
- [ ] Interactive Lesson Viewer renders lesson body, images, deep dives, micro-checks, and notes; progress updates persist.
- [ ] Export: user can export curriculum to at least Markdown and PDF; export job completes and returns downloadable artifact.
- [ ] Import: user can import an OPML or Markdown outline, preview mapping, and create or merge a curriculum.
- [ ] Versioning: user can view version history, see diffs, and revert to a previous version.
- [ ] Security: only authorized users can edit or export; all inputs are validated and XSS/vulnerability mitigations are in place.

## UI/UX Guidelines
- Follow StudyPath design system: consistent font, spacing, color, and accessible components.
- Desktop-first responsive layout, with the ability to collapse left panel and focus on editor for mobile.
- Use clear affordances for drag handles, save state, and AI operations. Present model latency using progress bars & streaming where available.
- Provide inline help tooltips for AI actions explaining what will happen and data usage.
- Minimize cognitive load: present only necessary options by default, expose advanced actions in an "Advanced" overflow menu.
- Ensure keyboard accessibility for all primary interactions, including drag-and-drop reordering and editor controls.

---

Deliver this spec to the engineering team or AI builder as the canonical prompt for implementing the Curriculum Detail / Editor. Include the API contracts, DB schema, and UX flows above as the blueprint for end-to-end development. for style.

CRITICAL DESIGN REQUIREMENTS:
- You MUST follow ALL design principles and patterns specified in the Design Reference above
- Do NOT deviate from the design specifications without explicit user permission
- Implement ALL visual design elements (colors, typography, spacing, shadows, animations) as specified
- Follow the layout patterns and component designs exactly as documented
- Ensure all interactions and micro-animations match the reference specifications

CRITICAL TECHNICAL REQUIREMENTS:
- React 18.3.1, React Router 6.30.1
- Tailwind CSS v3 with tailwind.config.js and custom keyframes
- @tailwindcss/typography plugin for rich text content
- Tailwind CSS animations (NOT Motion library or framer-motion)
- Sonner for toasts
- Recharts for data visualization
- Native fetch() with API utilities in src/lib/api.ts
- Design system with CSS custom properties
- Use RGB color values for theming
- When Supabase is configured: use Edge Functions for LLM and server-only logic; never expose API keys in the client

=== TASK ===
# Curriculum Detail / Editor

## Overview
Build a complete, production-ready "Curriculum Detail / Editor" feature for StudyPath: an editable, collaborative page that displays a saved curriculum (chapters → lessons), allows deep editing, reordering, AI-driven rewrites and Q&A, integrates search/filter and export/import, and connects to the Interactive Lesson Viewer and AI Curriculum Generation subsystems. This deliverable should include frontend UI, backend APIs, data models, integration points to AI services, search/embedding systems, and export/import pipelines. Provide concrete component-level instructions, API contracts, validation rules, and acceptance criteria so an engineering team or AI development tool can implement the feature end-to-end.

## Page Description (Full Detail)
What this page is:
- The Curriculum Detail / Editor is the canonical editable view for a single curriculum created by the AI or imported by a user. It displays the full tree: chapters and nested lessons (including optional "deep dive" sections), metadata, versioning, and collaboration tools. Users primarily use it to customize and refine AI-generated curricula before adopting or studying them.

Goals:
- Let users inspect a generated curriculum end-to-end.
- Allow structural edits: rename curriculum, add/remove chapters, reorder chapters & lessons via drag-and-drop, add/remove lessons and deep-dive sections.
- Allow content edits: inline editing for lesson titles, summaries, full lesson body, media placeholders, citations, and estimated times.
- Provide AI actions: rewrite a lesson (simplify, make technical, reframe for a different prior knowledge), generate alternate explanations, or answer follow-up questions anchored in the lesson context.
- Support collaboration: comments, read-only share links, share with collaborators (optional).
- Maintain audit trail: version history with diffs and revert.
- Integrate with Search & Filter, Interactive Lesson Viewer, Export & Import, and AI Curriculum Generation.

Connected features:
- Search & Filter: Search within this curriculum (and across the account) using full-text and embedding similarity; autosuggest on the title and text fields; filters for tags, estimated time, completeness, and media presence.
- Interactive Lesson Viewer: Open individual lessons in an interactive viewer modal/page for study mode (media rendering, expand/collapse deep dives, Q&A, micro-checks, notes).
- Export & Import: Export this curriculum (and attached notes/progress) to PDF, Markdown, CSV; accept imports/merges from OPML/Markdown.
- On-Demand AI Q&A & Rewrites: Provide an AI assistant panel scoped to the selected lesson, which receives lesson context (text, images, citations) and returns responses or updated lesson drafts.
- AI Curriculum Generation: Allow re-generation of subtrees or entire curriculum from an updated prompt or parameters, with diff preview.

UI elements and visual guidance (implement using the project design system / UI Component Kit):
- Curriculum Header: title (editable inline), short description/abstract, metadata row (created date, last edited, total estimated time, tags, privacy), primary action buttons (Publish/Adopt, Export, Duplicate, Share), and audit/version dropdown.
- Chapter List Panel (left/main column): collapsible list of chapters in order. Each chapter shows title, estimated time, count of lessons, drag handle, and controls to add/delete/rename.
- Lesson Cards (nested under chapters): compact card with lesson title, short summary, estimated time, thumbnail/media placeholder, badge for deep-dive presence, quick actions (Edit inline, AI-Rewrite, Open in Viewer, Move/Drag), and inline progress toggle (mark complete/in-progress).
- Central Editor / Canvas (right/main area): when a lesson is selected, show full editor: WYSIWYG or rich-text block editor with support for headings, lists, images, citations, code blocks, callouts, and "Deep Dive" collapsible blocks. Top of editor shows lesson metadata (estimated time, difficulty, tags, citations) and AI action bar (Ask AI, Rewrite: simpler/technical/concise, Generate alternative examples).
- Global Controls: top-right actions: Save, Undo/Redo, Publish, Duplicate, Export, Share. Autosave indicator and explicit Save button if needed.
- Audit Trail & Version History: side panel or modal listing versions with timestamp, author, change summary, diff preview, and revert button.
- Collaboration Controls: comment thread per lesson or per block, presence indicators, share link modal.
- Search Bar & Filters: persistent search input with autosuggest; filters (tags, estimated time range, lesson completeness, media present). Search results highlight and allow opening items in the editor.
- Toasts & Modals: confirmations for destructive actions (delete chapter/lesson), AI operation progress modals, import/export settings modal.

API integrations:
- AI services: endpoints to prompt models for curriculum generation, lesson rewrites, question-answering, and text-to-embedding generation.
- Search service: vector store for embeddings (e.g., Pinecone / Milvus / Redis OM), full-text index (e.g., ElasticSearch / Postgres full-text).
- Storage service: object storage for images/media, export artifacts.
- Backend: REST/GraphQL endpoints for curriculum CRUD, versioning, collaboration, import/export jobs, and progress tracking.

## Components to Build
1. CurriculumHeader component
   - Inline editable title/description with autosave + save UI.
   - Metadata display and control buttons: Publish, Export, Duplicate, Share.
   - API calls: PATCH /curricula/:id for title/description/tags.

2. ChapterList & ChapterItem
   - Draggable list using a robust drag-and-drop library (e.g., react-beautiful-dnd or dnd-kit).
   - Expand/collapse chapters to reveal LessonCards.
   - Controls: add chapter, rename, delete (with modal confirmation), reorder.

3. LessonCard
   - Compact preview of lesson: title, summary, estimated time, thumbnail placeholder.
   - Action buttons: Edit (open in Canvas), AI Rewrite (open AI action modal), Open Viewer (open Interactive Lesson Viewer), Move/Drag, Mark Complete.
   - Badge: deep-dive count, media presence.

4. LessonEditor (Canvas)
   - Rich text editor with block structure (Title, Summary, Body, Deep Dive blocks).
   - Block-level operations: add/remove deep dive, collapse/expand, move block up/down.
   - Support media insertion: image upload placeholders and image request suggestions from AI (list of suggested images per lesson).
   - Inline AI Action Bar: Ask AI, Rewrite options (simpler/technical/concise), Alternate examples generator, Regenerate lesson.
   - Autosave & explicit Save; Undo/Redo stack.
   - API: PUT/PATCH /curricula/:id/lessons/:lessonId

5. AI Action Modal / Panel
   - Context-aware prompt builder: include selected lesson text, metadata, and user-chosen rewrite parameters.
   - Options: rewrite tone (simpler/more technical/more concise), preserve/cite sources, generate alternative examples, produce MC micro-check questions.
   - Show AI output side-by-side diff with proposed changes and accept/reject granular changes (apply to lesson).
   - API interactions: POST /ai/rewrite, POST /ai/qa

6. Interactive Lesson Viewer
   - Read-only but interactive mode for the lesson: render media, expand/collapse deep dives, inline Q&A, micro-checks, notes panel, and progress controls.
   - Integrate with On-Demand AI Q&A: message box sends the current lesson context.
   - Track progress updates to backend.

7. Search & Filter Panel / Bar
   - Autosuggest for curriculum titles, lesson titles, and tags.
   - Perform combined full-text + embedding similarity search; show highlighted snippets and ranked list with facets (tags, media presence, estimated time).
   - API: GET /search?q=...&filters=...

8. Export & Import
   - Export modal: choose format(s) (PDF, Markdown, ZIP of Markdown+images, CSV for lesson metadata), options (include notes/progress), and theme options for PDF.
   - Implement export jobs: POST /curricula/:id/export that returns job id and download link.
   - Import modal: upload OPML/Markdown; show parse preview and merge options (replace/append/create new).
   - Import API: POST /import with parsing and validation; map imported outline to internal schema.

9. Versioning & Audit Trail
   - Backend version store for curriculum and lesson snapshots.
   - UI list of versions with diffs and revert action.
   - API: GET /curricula/:id/versions, POST /curricula/:id/versions/:versionId/revert

10. UI Component Kit (Design System)
    - Buttons, modals, forms, loaders, cards, badges, toasts, editors, avatars, dropdowns, drag handles.
    - Accessibility-ready components (keyboard nav for drag/drop, aria labels, focus states).

## Implementation Requirements

### Frontend
- Framework: React (web) using TypeScript. For mobile parity, components should be portable to React Native / Expo later; keep logic separated from platform-specific UI.
- State management: use Redux Toolkit or React Query for server state and optimistic updates; local editor state with undo/redo stack.
- Editor: use ProseMirror/TipTap or Slate for block-level editing and nested collapsible "Deep Dive" blocks. Ensure plugin for custom blocks and annotations.
- Drag-and-drop: use dnd-kit with sortable context for nested drag (chapters and lessons).
- AI Interactions:
  - Create a modular AI client wrapper that calls backend AI endpoints, shows progress, streaming responses where possible.
  - Provide client-side helpers to build AI prompts: include lesson text, user preferences (tone, depth), and curriculum context (prior knowledge, time).
- Autosave: debounce saves (e.g., 1.5s after edit) and show unsaved changes indicator; allow explicit save and version snapshot triggers.
- Accessibility: keyboard operations for reordering, aria attributes for editor blocks, high-contrast modes.
- Tests: unit tests for components, integration tests for drag-and-drop and editor, end-to-end tests for main user flows.

### Backend
- Tech: Node.js with TypeScript (Express or Fastify) or a GraphQL server (Apollo). Use Postgres for relational data and versioning, and a vector store (Pinecone/Redis/Milvus) for embeddings.
- Database Schemas (high-level):
  - curricula table: id, owner_id, title, description, tags (jsonb), estimated_time_mins, status (draft/published), privacy, created_at, updated_at, metadata jsonb.
  - chapters table: id, curriculum_id, title, position, metadata jsonb, created_at, updated_at.
  - lessons table: id, chapter_id, curriculum_id, title, summary, body (rich JSON document), estimated_time_mins, difficulty, media (jsonb), embeddings (vector), position, created_at, updated_at.
  - lesson_versions table: id, lesson_id, curriculum_id, snapshot (JSONB), author_id, change_summary, created_at.
  - curriculum_versions table: id, curriculum_id, snapshot (JSONB), author_id, change_summary, created_at.
  - notes table: id, user_id, lesson_id, content, created_at, updated_at.
  - progress table: id, user_id, lesson_id, status (not_started/in_progress/completed), last_active_at, time_spent_seconds.
  - ai_jobs table: id, user_id, type (rewrite/qa/generate/export), status, input_payload (jsonb), output_payload (jsonb), started_at, finished_at.
- Endpoints (see API Endpoints section).
- AI services:
  - POST /ai/curriculum/generate: accepts prompt and parameters (time, depth, focus, priorKnowledge) and returns structured curriculum draft (chapters -> lessons) with estimated times, image suggestions, and citations.
  - POST /ai/rewrite: accepts lesson context and rewrite params; returns revised lesson body with diff metadata.
  - POST /ai/qa: accepts context and question; returns answer plus citations and suggested lesson edits.
  - POST /ai/embed: returns embeddings for supplied text for indexing.
- Search:
  - Ingest lesson and curriculum text into full-text index and produce embeddings to store in vector DB. Provide combined search endpoint that ranks by hybrid score.
- Export/Import:
  - Implement background job worker (BullMQ/Sidekiq-style) for heavy tasks: PDF generation, markdown conversion, image bundling, import parsing & validation.
- Versioning:
  - Create snapshots on major changes or on user request. Store diffs and full snapshots to allow revert.
- Security:
  - All endpoints require authentication (JWT/OAuth). Authorization rules: users can only edit curricula they own or that are shared with edit permissions. Provide role-based access for collaborators.

### Integration
- Frontend calls backend REST/GraphQL endpoints for CRUD and AI jobs. Backend proxies calls to AI provider (OpenAI/Anthropic/etc.) and to vector store.
- When a lesson is saved: update lessons table, generate new embedding asynchronously (POST /ai/embed), update vector store, and re-index in full-text search.
- AI Rewrite flow:
  - Frontend sends rewrite request to backend with lesson_id, rewrite_params.
  - Backend calls AI service with constructed prompt including lesson snapshot and parameters; stores ai_job record; streams/returns results.
  - On accept, frontend applies patch to lesson via PATCH /curricula/:id/lessons/:lessonId and creates a lesson_version snapshot.
- Export flow:
  - User initiates export; backend enqueues export job; worker generates artifact, stores in S3, and updates ai_jobs with download URL.
- Import flow:
  - Upload file to backend; worker parses file into internal schema, returns preview; user confirms mapping; then worker persists as new curriculum or merged into existing.

## User Experience Flow
1. Entry: User opens Curriculum Detail for a selected curriculum (GET /curricula/:id). Page loads curriculum header, chapter list, and first lesson in Editor or a prompt to select a lesson.
2. Navigation: User collapses/expands chapters, uses search bar to find a lesson, or uses filters to narrow content.
3. Reorder: User drags lessons between chapters or reorders chapters. On drop, frontend optimistically reorders and sends PATCH /curricula/:id/reorder with new positions; backend validates and persists.
4. Edit: User clicks a LessonCard -> LessonEditor opens. User edits text/blocks. Autosave persists changes after debounce. Each save creates a version snapshot if changes are significant.
5. Deep Dive: User adds a Deep Dive block: an empty collapsible block in the lesson. User can move it, edit it, or delete it.
6. AI Rewrite: User selects a rewrite option (simpler/more technical). AI panel opens showing proposed rewrite side-by-side; user accepts fully or partially. On accept, changes are applied and a version snapshot created.
7. On-Demand Q&A: In the editor or Interactive Viewer, user asks a question. The system sends lesson context to AI and returns anchored answers; user can insert answer back into lesson as a note or content block.
8. Preview & Viewer: User opens Interactive Lesson Viewer to preview how learners will see the lesson. Viewer supports micro-checks and notes.
9. Export/Import: User exports curriculum to PDF/Markdown via Export modal. For import, user uploads OPML/Markdown, previews mapping, and confirms merge/create.
10. Version & Revert: User opens version history, compares diffs, and reverts to a prior version if desired.
11. Publish/Adopt: When satisfied, user clicks Publish or Adopt to mark curriculum as ready for study; this triggers publishing workflow and optionally notifies collaborators.

## Technical Specifications

- Data Models (detailed)
  - Curriculum
    - id: uuid
    - owner_id: uuid
    - title: string (max 256)
    - description: string (nullable)
    - tags: jsonb [string]
    - estimated_time_mins: integer
    - status: enum [draft, published, archived]
    - privacy: enum [private, shared, public]
    - metadata: jsonb (e.g., priorKnowledge, focusAreas)
    - created_at, updated_at
  - Chapter
    - id: uuid
    - curriculum_id: uuid (fk)
    - title: string
    - position: integer
    - metadata: jsonb
    - created_at, updated_at
  - Lesson
    - id: uuid
    - chapter_id: uuid (fk)
    - curriculum_id: uuid (fk)
    - title: string
    - summary: text
    - body: jsonb (block structure with types: paragraph, heading, image, deep_dive, quiz)
    - estimated_time_mins: integer
    - difficulty: enum [intro, intermediate, advanced]
    - media: jsonb [{type, url, caption}]
    - citations: jsonb [{text, url}]
    - embeddings_id: string (ref to vector store id)
    - position: integer
    - created_at, updated_at
  - LessonVersion
    - id, lesson_id, curriculum_id, snapshot: jsonb, author_id, change_summary, created_at
  - AIJob
    - id, user_id, type, status, input_payload, output_payload, started_at, finished_at

- API Endpoints (examples)
  - GET /api/curricula/:id
  - PATCH /api/curricula/:id
  - POST /api/curricula/:id/duplicate
  - POST /api/curricula/:id/export  -> returns job id
  - POST /api/curricula/import (multipart)
  - POST /api/curricula/:id/chapters (create)
  - PATCH /api/chapters/:id (rename/move)
  - DELETE /api/chapters/:id
  - PATCH /api/curricula/:id/reorder  (payload: {chapters:[{id,position}], lessons:[{id,position,chapterId}]})
  - GET /api/curricula/:id/versions
  - POST /api/curricula/:id/versions/:versionId/revert
  - GET /api/lessons/:lessonId
  - PATCH /api/lessons/:lessonId
  - POST /api/lessons/:lessonId/ai/rewrite  (body: {params})
  - POST /api/lessons/:lessonId/ai/qa (body: {question, contextOptions})
  - POST /api/ai/curriculum/generate (body: {prompt, timeEstimateMins, depth, focusAreas, priorKnowledge})
  - POST /api/ai/embed (body: {texts:[]})
  - GET /api/search?q=&filters=
  - POST /api/export/jobs/:jobId/status

- Security
  - Auth: JWT Bearer tokens; endpoints validate token and check ownership or shared access based on ACL.
  - Authorization: CRUD restricted to owner or collaborators with edit permission; read access for shared/public.
  - Rate limiting for AI endpoints per user to avoid abuse.
  - Data privacy: exports only available to authorized users; signed temporary URLs for export downloads.
  - Input sanitization: sanitize HTML and rich text on save to prevent XSS. Use CSP and store only safe JSON block structures.

- Validation
  - Title: required, 1-256 chars.
  - Estimated time: integer >= 1 and < 10000.
  - Lesson body: validated JSON schema with allowed block types.
  - Import: validate file size, format; produce parsing errors with line/offset where possible.
  - Reorder payload: validate that provided IDs belong to the curriculum.

## Acceptance Criteria
- [ ] Curriculum page loads with full chapter/lesson tree for a saved curriculum; lesson selection loads editor content.
- [ ] User can reorder chapters and lessons via drag-and-drop; reordering persists and positions are stable across reloads.
- [ ] Inline editing: user can edit lesson title, summary, and the body; autosave and explicit save both persist changes and create version snapshots.
- [ ] Deep-dive sections can be added, expanded/collapsed, moved, and deleted; their presence is reflected in lesson metadata.
- [ ] AI rewrite: user can request a rewrite (simpler/more technical/concise); AI returns suggested copy; user can accept to update lesson and create version snapshot.
- [ ] On-demand Q&A returns context-anchored answers and allows inserting answers into notes or lesson body.
- [ ] Search & Filter returns results across curricula, lessons, and notes; supports autosuggest and facet filters.
- [ ] Interactive Lesson Viewer renders lesson body, images, deep dives, micro-checks, and notes; progress updates persist.
- [ ] Export: user can export curriculum to at least Markdown and PDF; export job completes and returns downloadable artifact.
- [ ] Import: user can import an OPML or Markdown outline, preview mapping, and create or merge a curriculum.
- [ ] Versioning: user can view version history, see diffs, and revert to a previous version.
- [ ] Security: only authorized users can edit or export; all inputs are validated and XSS/vulnerability mitigations are in place.

## UI/UX Guidelines
- Follow StudyPath design system: consistent font, spacing, color, and accessible components.
- Desktop-first responsive layout, with the ability to collapse left panel and focus on editor for mobile.
- Use clear affordances for drag handles, save state, and AI operations. Present model latency using progress bars & streaming where available.
- Provide inline help tooltips for AI actions explaining what will happen and data usage.
- Minimize cognitive load: present only necessary options by default, expose advanced actions in an "Advanced" overflow menu.
- Ensure keyboard accessibility for all primary interactions, including drag-and-drop reordering and editor controls.

---

Deliver this spec to the engineering team or AI builder as the canonical prompt for implementing the Curriculum Detail / Editor. Include the API contracts, DB schema, and UX flows above as the blueprint for end-to-end development.

=== SUCCESS CRITERIA ===
# Success Criteria Checklist

## Code Quality

### TypeScript
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] All functions and components have proper type definitions
- [ ] No `any` types used (use `unknown` if type is truly unknown)
- [ ] Props interfaces defined for all components
- [ ] API responses have type definitions

### Code Standards
- [ ] All imports use path aliases (@/ prefix)
- [ ] Components follow the established naming convention
- [ ] Files are organized in correct directories
- [ ] No unused imports or variables
- [ ] Consistent code formatting

## Component Implementation

### UI Components
- [ ] Use shadcn/ui components (Button, Card, Input, etc.) instead of building from scratch
- [ ] All interactive elements have hover states
- [ ] Components use the `cn()` utility for class merging
- [ ] Proper TypeScript props interfaces defined
- [ ] Components are responsive (mobile, tablet, desktop)

### Animations
- [ ] Motion library used for all animations (NOT framer-motion)
- [ ] Page transitions implemented with fade/slide
- [ ] Interactive elements have whileHover/whileTap animations
- [ ] List items use stagger animations where appropriate
- [ ] Animations respect `prefers-reduced-motion`

### Icons
- [ ] Lucide React icons used consistently
- [ ] Icons have consistent sizing (h-4 w-4, h-5 w-5, h-6 w-6)
- [ ] Icon colors match design system (text-primary, text-muted-foreground)

## Data Management

### React Query
- [ ] All data fetching uses React Query hooks
- [ ] Query keys follow the established pattern
- [ ] Mutations invalidate related queries
- [ ] Loading and error states handled
- [ ] Optimistic updates implemented where appropriate

### Forms
- [ ] Forms use react-hook-form
- [ ] Validation uses Zod schemas
- [ ] Error messages display properly
- [ ] Form submission shows loading state
- [ ] Success/error feedback via toast notifications

### API Layer
- [ ] API functions in src/api/ directory
- [ ] Axios used for HTTP requests
- [ ] Proper error handling with try/catch
- [ ] Auth tokens handled by interceptors
- [ ] Type-safe API function signatures

## User Experience

### Notifications
- [ ] Sonner toasts used for all notifications
- [ ] Success actions show success toast
- [ ] Errors show descriptive error messages
- [ ] Loading states show toast.loading()

### Loading States
- [ ] Skeleton loaders shown during data fetch
- [ ] Buttons show loading state during submission
- [ ] Disabled state applied during async operations

### Error Handling
- [ ] Network errors caught and displayed
- [ ] User-friendly error messages (no stack traces)
- [ ] Fallback UI for error states
- [ ] No unhandled promise rejections

## Navigation

### Route Accessibility
- [ ] All pages have routes defined in router configuration
- [ ] Every page is accessible through navigation (menu, sidebar, or direct URL)
- [ ] Main pages (Dashboard, Home, Settings, etc.) accessible from primary navigation
- [ ] Secondary pages accessible through contextual navigation or direct links
- [ ] Deep-linked pages have breadcrumbs or back navigation
- [ ] 404/Not Found page implemented for invalid routes
- [ ] Protected routes have proper authentication checks
- [ ] Navigation state persists across page refreshes where appropriate

### Navigation UX
- [ ] Active route highlighted in navigation menu
- [ ] Clear visual hierarchy in navigation structure
- [ ] Mobile navigation is accessible and usable
- [ ] Navigation items have hover/focus states
- [ ] Nested routes show parent-child relationships
- [ ] User can always return to main areas (Dashboard/Home)

## Styling

### Tailwind CSS
- [ ] Tailwind v3 classes used
- [ ] HSL color variables from design system
- [ ] Custom CSS properties used where defined
- [ ] Responsive breakpoints: mobile-first approach
- [ ] Dark mode support via CSS variables

### Design System
- [ ] Colors use theme variables (primary, secondary, accent)
- [ ] Spacing uses Tailwind scale (p-4, gap-6, etc.)
- [ ] Border radius uses theme values (rounded-lg)
- [ ] Shadows use theme values (shadow-card)
- [ ] Typography follows Inter font system

## Accessibility

- [ ] Semantic HTML elements used
- [ ] Buttons have descriptive labels
- [ ] Forms have proper labels
- [ ] Focus states visible on interactive elements
- [ ] Color contrast meets WCAG standards

## Performance

- [ ] No console.log statements in production code
- [ ] No console errors in browser
- [ ] Images optimized (WebP, lazy loading)
- [ ] Large lists use virtualization if needed
- [ ] React Query cache configured appropriately

## Testing Readiness

- [ ] Components structured for easy testing
- [ ] Business logic separated from presentation
- [ ] Mock-friendly API layer
- [ ] No hardcoded values that should be configurable
- [ ] Environment variables properly configured

## Final Checks

- [ ] Code builds without errors (`npm run build`)
- [ ] Development server runs without errors (`npm run dev`)
- [ ] No TypeScript errors in editor
- [ ] Browser console is clean (no errors or warnings)
- [ ] All functionality works as expected
- [ ] Code follows existing project patterns
- [ ] Changes are consistent with the rest of the codebase



IMPORTANT: ALL styling and design decisions must follow the Design Reference section above EXACTLY. Do not make arbitrary design choices.

Analyze the existing project structure and implement the task following the patterns already established. Ensure all success criteria are met.